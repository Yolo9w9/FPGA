`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 2019/11/14 16:24:19
// Design Name: 
// Module Name: xilinx_wmy
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module xilinx_wmy(
input FPGA_RESET ,
input SYS_CLK ,

output 	wire	PA1_UART4_RX	,
input 	wire	PA1_UART4_TX	,

//送到stm32计数，暂时不管
input 	wire	DATA	,
input 	wire	WMD	,

//LVDS差分信号
input 	wire	LVDSR	,
output 	wire	LVDST	,

//ttl
output 	wire	WMDATA	,
input 	wire	RIDATA	,


//时钟
input 	wire	EICLK	,
output 	wire	WMCLK	,
input 	wire	RICLK	,
//光端机
input 	wire	ORIDATA	,
output 	wire	OTDATA	,
//HDB3，1Mhz
input 	wire	HDB3P	,
input 	wire	HDB3N	,
output 	wire	HDB3CODE1,
output 	wire	HDB3CODE2	,

input 	wire	M4SPI2_MOSI	,
input 	wire	M4SPI2_MISO	,
input 	wire	M4SPI2_SCK,
input 	wire	M4SPI2_NSS,	
 
output 	wire	BS	,

output 	wire	FS	

   
   
    );
    
    
   
 wire clk ;  
  clk_wiz_0 instance_name
   (
    // Clock out ports
    .clk_out1(clk),     // output clk_out1
   // Clock in ports
    .clk_in1(SYS_CLK));      // input clk_in1
 
    
reg reset_n;

 

reg [15:0]	reset_count;
reg [31:0]	count;

 
always@(posedge clk)
begin
	if(count==65536000)	count <= 0;
	else						count <= count + 1;
 
  
	if(reset_count==65535)	reset_count <= reset_count;
	else							reset_count <= reset_count + 1;
	reset_n<= (reset_count==65535);
end

















//////////////////////////////////////////////////////////////////////////////////////

reg U4TXD0,U4TXD1,U4TXD2,U4TXD3;
always@(posedge clk)
begin
	U4TXD3<=U4TXD2;
	U4TXD2<=U4TXD1;
	U4TXD1<=U4TXD0;
	U4TXD0<=PA1_UART4_TX;
end

wire fpga_write;
wire [15:0]	fpga_address;
wire [15:0]	fpga_wdata;
uart_rx	uart_rx_inst(
					.rx(U4TXD3),
					.reset_n(reset_n),
					.clk(clk),
					.address(fpga_address),
					.write(fpga_write),
					.wdata(fpga_wdata),
					.start_rx()

);
					
reg recv_edge ;
reg send_edge ;
					
reg clk_out_in;
reg [1:0]interface_select;
reg low_high=0;
reg FS_BSse;
always@(posedge clk)
begin
	if(reset_n==1'b0)
	begin
		wmy_pause <= 1;//暂停0，继续1
		wmy_run <= 0;//运行1，停止0
		base_code_type   <=  10;
		baseband_type   <=  4; //26表示开关码   
		baseband_sw16   <= 0;// 16'b1011_0111_0111_1000;    
		baseband_rate  <= 5;  
		reg03<=  0;  
		clk_out_in<=  0;  
		NCO_WMY_clk_nei<=1073741824/32;	//32.768*freq
		NCO<=4*32;	//2^32/NCO_WMY_clk_nei,先在单片机里面计算好，然后再发送过来
		interface_select<=0;
		FS_BSse<=0;
		Frame_Head    <= 7'b0011011;
   end
   else	if(fpga_write==1'b1)
	begin
			case(fpga_address[15:12])
				4'h7://基带数据设置
				begin
					case(fpga_address[7:0])	
					8'h00:baseband_type   <=  fpga_wdata[7:0];   // 
					8'h01:baseband_rate  <= fpga_wdata[7:0];  //采样率,失效
					8'h02:baseband_sw16    <= fpga_wdata[15:0];  //  
					8'h03:baseband_sw16    <= fpga_wdata; //
					8'h04:base_code_type    <= fpga_wdata; //
					
					8'h05:reg03 <= fpga_wdata;//误码数设置:0没有;1:10^-3 2:10^-4
					8'h06:reg04 <= reg04+1;//重新同步,0-1-0翻转后重新同步					
					8'h07:wmy_pause <= fpga_wdata;//暂停/继续
					8'h08:wmy_run <= fpga_wdata;//开始运行
					8'h09:wmy_pause <= fpga_wdata;//暂停/继续
					
					
					 
 					8'h0a:NCO_WMY_clk_nei[15: 0] <= fpga_wdata[15:0];
					8'h0b:NCO_WMY_clk_nei[31:16] <= fpga_wdata[15:0];
					8'h0c:clk_out_in <= fpga_wdata;//内时钟还是外时钟
 					8'h0d:NCO[15: 0] <= fpga_wdata[15:0];
					8'h0e:NCO[31:16] <= fpga_wdata[15:0];
					8'h0f:interface_select <= fpga_wdata[1:0];
					
					8'h10:recv_edge <= fpga_wdata;
					8'h11:send_edge <= fpga_wdata;
					
					8'h12:FS_BSse <= fpga_wdata;
					
					
					endcase
				end 
			endcase
	end		 
end


reg [31:0 ]phase;
reg [31:0 ]NCO_WMY_clk_nei;
reg WMY_clk_nei;
always @(posedge clk)begin
 
	phase <= NCO_WMY_clk_nei + phase;
	WMY_clk_nei<= ~phase[31];
end

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
LineCode LineCode_init1(
					.clk(clk),
					.reset_n(reset_n),	
					.reg1(base_code_type),//编码类型
					.dataclk(WMCLK),
					.data(WMDATA),
					.ocode1(HDB3CODE1),
					.ocode2(HDB3CODE2)					
);

 
 
 
 
 
  
////////////////////////////////////////////////////////////////////////////////
wire Syn_RHDB31,Syn_RHDB32;
//将收到的RZ信号转换为NRZ信号

	wire LineDecode_RECOVER_CLK;   			
	wire LineDecode_RECOVER_DATA;  
// Generated by Quartus II 64-Bit Version 13.1 (Build Build 162 10/23/2013)
// Created on Mon Aug 28 17:35:43 2017
reg [31:0]NCO;
 

 

LineDecode LineDecode_inst
(
	.clk(clk) ,	// input  clk
	.reset_n(reset_n) ,	// input  reset_n
	.rate(baseband_rate) ,	// input [7:0] rate
	.NCO(NCO) ,	// input [7:0] rate
	.base_code_type(base_code_type) ,	// input [7:0] base_code_type
 
	.codein1(HDB3N) ,	// input  codein1
	.codein2(HDB3P) ,	// input  codein2
	.Syn_RHDB31(Syn_RHDB31) ,	// output  Syn_RHDB31
	.Syn_RHDB32(Syn_RHDB32) ,	// output  Syn_RHDB32
	.declk(LineDecode_RECOVER_CLK) ,	// output  declk
	.decode(LineDecode_RECOVER_DATA) 	// output  decode
); 
 


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////误码仪////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////误码仪/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////误码仪////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////误码仪////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////误码仪/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////误码仪/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////误码仪/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////误码仪////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////误码仪///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////误码仪//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////误码仪///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////误码仪////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////误码仪///误码仪///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////误码仪//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

reg [7:0]baseband_type ;
reg [7:0]baseband_rate ;
reg [15:0]baseband_sw16;
reg [7:0]Insert_Err_reg; 

// Generated by Quartus II 64-Bit Version 13.1 (Build Build 162 10/23/2013)
// Created on Tue Aug 22 13:59:27 2017

reg wmy_pause=1;//暂停0，继续1
reg wmy_run=0;//运行1，停止0

wire [7:0] reg01=baseband_rate;//时钟速率
reg [7:0] reg02 ;//码长设置
always@(posedge clk)
	reg02<=baseband_type ;//码长设置

reg [7:0] reg03;//误码数设置:0没有;1:10^-3 2:10^-4
reg       reg04;//重新同步,0-1-0翻转后重新同步
reg  wmy_i;     //误码仪输入(可能比误码仪输入晚)
reg  wmy_clk_i;     //误码仪输入(可能比误码仪输入晚)
reg  wmy_clk_e;     //误码仪外加时钟
always@(posedge count[1])
begin
	if(clk_out_in)
		wmy_clk_e<=EICLK ;  
	else
		wmy_clk_e<=WMY_clk_nei ;  

	case(interface_select)	
		0:
		begin
			wmy_i<=RIDATA ; //ORIDATA;//LVDSR;//
			wmy_clk_i<=RICLK ; //
		end
		1:
		begin
			wmy_i<=ORIDATA ; //;//LVDSR;//
			wmy_clk_i<=RICLK ; //
		end
		2:
		begin	
			wmy_i<=LVDSR ; //;//;//
			wmy_clk_i<=RICLK ; //
		end
		3:
		begin	
			wmy_i<=LineDecode_RECOVER_DATA;//RIDATA ; //ORIDATA;//LVDSR;//
			wmy_clk_i<=LineDecode_RECOVER_CLK;//RICLK ; //
		end	
	endcase

end

assign WMCLK=FS_BSse?count[5]:wmy_clk_o ;//;//
assign LVDST=FS_BSse?E1_Data_Out:wmy_o; 
assign OTDATA=FS_BSse?E1_Data_Out:wmy_o; 
assign WMDATA=FS_BSse?E1_Data_Out:wmy_o; //E1_Data_Out;//




wmy wmy_inst
(
	.clk(clk) ,	// input  clk
	.reset_n(reset_n) ,	// input  reset_n
	.reg01(reg01) ,	// input [7:0] reg01
	.reg02(reg02) ,	// input [7:0] reg02
	.reg03(reg03) ,	// input [7:0] reg03
	.reg04(reg04) ,	// input  reg04
	.baseband_sw16(baseband_sw16) ,	// input  reg04
	.wmy_o(wmy_o) ,	// output  wmy_o
	.wmy_clk_o(wmy_clk_o) ,	// output  wmy_clk_o
	.wmy_i(wmy_i) ,	// input  wmy_i
	.wmy_clk_i(wmy_clk_i) ,	// input  wmy_i	
	.wmy_clk_e(wmy_clk_e) ,	// input  wmy_i
	.recv_edge(recv_edge) ,	// input  wmy_i	
	.send_edge(send_edge) ,	// input  wmy_i

   .sonyc_led(BS) ,	// input  wmy_i
	
	.data_c(data_c) ,	// output  data_c
	.wm_c(wm_c) ,	// output  wm_c
	
	.wmy_run(wmy_run) ,	// input  wmy_run
	.wmy_pause(wmy_pause) ,	// input  wmy_pause
	
	.data_count(data_count) ,	// output [31:0] data_count
	.wmy_count(wmy_count) ,	// output [31:0] wmy_count
	.wmy_time_500ms(wmy_time_500ms) ,	// output [15:0] wmy_time_500ms
	.data_wmy_count_valid(data_wmy_count_valid) 	// output  data_wmy_count_valid
);
wire [47:0]data_count;//收码计数值
wire [47:0]wmy_count;//误码计数值
wire  data_wmy_count_valid;//误码仪计数有效，每隔500ms计算一次
wire [31:0]wmy_time_500ms;//误码计时

wire  wmy_o;    //误码仪输出
wire  wmy_clk_o;//误码仪时钟输出
wire  data_c;    //收码计数脉冲
wire  wm_c;       //误码计数脉冲
 



 
reg wmy_pulse_valid;
reg [7:0]wmy_pulse_data;
reg [5:0]wmy_pulse_st;
reg [31:0]wmy_pulse_count;
parameter uart_send_delay=200000;
reg sendst;
always@(posedge clk)
begin	
			if(sendst==0)
			begin	
				wmy_pulse_valid <= 0;
				wmy_pulse_st <= 0;
				if(FS_BSse?data_wmy_count_validFS:data_wmy_count_valid)
				begin
					sendst<=1;
				end
			end
	      else if((wmy_pulse_count>=uart_send_delay) && (uart_tx_busy==0))
			begin
				wmy_pulse_st <= wmy_pulse_st+1;
				wmy_pulse_count <= 0;
				wmy_pulse_valid <= 1;
				case(wmy_pulse_st)
				0:wmy_pulse_data <= 8'h7b;
				1:wmy_pulse_data <= 8'hb7;
				2:wmy_pulse_data <= FS_BSse?data_countFS[47:40]:data_count[47:40];
				3:wmy_pulse_data <= FS_BSse?data_countFS[39:32]:data_count[39:32];
				4:wmy_pulse_data <= FS_BSse?data_countFS[31:24]:data_count[31:24];
				5:wmy_pulse_data <= FS_BSse?data_countFS[23:16]:data_count[23:16];
				6:wmy_pulse_data <= FS_BSse?data_countFS[15:8]:data_count[15:8];
				7:wmy_pulse_data <= FS_BSse?data_countFS[7:0]:data_count[7:0];
				8:wmy_pulse_data <= FS_BSse?wmy_countFS[47:40]:wmy_count[47:40];
				9:wmy_pulse_data <= FS_BSse?wmy_countFS[39:32]:wmy_count[39:32];
				10:wmy_pulse_data <= FS_BSse?wmy_countFS[31:24]:wmy_count[31:24];
				11:wmy_pulse_data <= FS_BSse?wmy_countFS[23:16]:wmy_count[23:16];
				12:wmy_pulse_data <= FS_BSse?wmy_countFS[15:8]:wmy_count[15:8];
				13:wmy_pulse_data <= FS_BSse?wmy_countFS[7:0]:wmy_count[7:0];
				14:wmy_pulse_data <= FS_BSse?wmy_time_500msFS[31:24]:wmy_time_500ms[31:24];
				15:wmy_pulse_data <= FS_BSse?wmy_time_500msFS[23:16]:wmy_time_500ms[23:16];
				16:wmy_pulse_data <= FS_BSse?wmy_time_500msFS[15:8]:wmy_time_500ms[15:8];
				17:wmy_pulse_data <= FS_BSse?wmy_time_500msFS[7:0]:wmy_time_500ms[7:0];
				18:begin wmy_pulse_data <= FS_BSse?FS:BS;sendst<=0;end
				default:sendst<=0;
				endcase					
			end
			else
			begin
				wmy_pulse_count <= wmy_pulse_count + 1;
				wmy_pulse_valid <= 0;
			end
 
end



wire uart_tx_busy;
uart_tx uart_tx_inst
(
	.tx(PA1_UART4_RX) ,	// output  tx_sig
	.clk( clk) ,	// input  clk_sig
	.valid(wmy_pulse_valid) ,	// input  valid_sig
	.data(wmy_pulse_data) ,	// input [7:0] data_sig
	.parity(1) ,	// input  parity_sig
	.busy(uart_tx_busy) 	// output  busy_sig
); 

reg [7:0]base_code_type;
 
 




reg[6:0] Frame_Head    = 7'b0011011; 
 
 E1_Framer U_E1_Framer(	  
	.Clk16M				(SYS_CLK          ),
	.Rst                (~reset_n             ),
	.Clk_E1             (count[5]      ),	
	.Frame_Head          (Frame_Head   ),	

   
  
	.E1_Data_Out    	(E1_Data_Out     )
);
 
 
 
 wire E1_Data_Out;
 
 
  
  
////////////////////////////////////////////////////////////////////////////////////////////
//																														//
//														demultiple													//	
//																													 	//
//																													 	//
////////////////////////////////////////////////////////////////////////////////////////////
wire DMUX; 
assign DMUX = wmy_i;
//////////////////

wire demux_sclk; 
wire dvalid;
//////////////////////////位同步////////////////////////////
///////////////恢复出的时钟可以用在很多情况下//////////////////
///////////////////////////////////////////////////////////

dpll_easy	dpll_inst(
				.reset_n(reset_n),
				.clk(clk),
				.din(DMUX),
				.dclock(demux_sclk),
				.dvalid(dvalid));

reg 	[7:0]	demux_count;
always@(posedge clk)
begin
	if(dvalid)
	begin
		demux_count <= demux_count + 1;
	end
end

 

/////////////////////将复接数据延时一个时钟/////////////////////
reg pre_demux_sclk;
always@(posedge clk)
begin
	DMUX0 <= DMUX;
	pre_demux_sclk <= demux_sclk;
	if(pre_demux_sclk==0 && demux_sclk==1)
	begin
		DMUX1 <= DMUX0;
	end
end
reg DMUX0,DMUX1;


wire demultiple_source_valid;
wire [7:0]	demultiple_source_data0;
wire [7:0]	demultiple_source_data1;
wire [7:0]	demultiple_source_data2;
wire [7:0]	demultiple_source_data3;

wire slot_sync;
wire demultiple_FS;
demultiple	demultiple_inst(
						.sclk(demux_sclk),
						.sd(DMUX1),
						.clk(clk),
						.reset_n(reset_n),
						.head(Frame_Head),
						.source_valid(demultiple_source_valid),
						.source_data0(demultiple_source_data0),
						.source_data1(demultiple_source_data1),
						.source_data2(demultiple_source_data2),
						.source_data3(demultiple_source_data3),
						.slot_sync(slot_sync),
						
						.FS(demultiple_FS),
						
	.reg04(reg04) ,	// input  reg04	
	.wmy_run(wmy_run) ,	// input  wmy_run
	.wmy_pause(wmy_pause) ,	// input  wmy_pause
	
	.data_count(data_countFS) ,	// output [31:0] data_count
	.wmy_count(wmy_countFS) ,	// output [31:0] wmy_count
	.wmy_time_500ms(wmy_time_500msFS) ,	// output [15:0] wmy_time_500ms
	.data_wmy_count_valid(data_wmy_count_validFS) 	// output  data_wmy_count_valid
);
wire [47:0]data_countFS;//收码计数值
wire [47:0]wmy_countFS;//误码计数值
wire  data_wmy_count_validFS;//误码仪计数有效，每隔500ms计算一次
wire [31:0]wmy_time_500msFS;//误码计时					
  
 
 
assign FS = slot_sync;
 
 
 
 











 
    
    
endmodule
